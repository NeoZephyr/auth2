生成授权码（用户与第三方建立联系） -> 生成访问令牌 -> 使用访问令牌

许可类型
授权码
隐式许可
客户端凭据许可
资源拥有者凭据许可

资源拥有者
第三方软件
授权服务
受保护资源

1. 资源拥有者使用第三方软件
2. 第三方软件引导授权，跳转到授权服务，附带第三方软件的回调地址。授权服务验证客户端合法性及用户登录状态，生成授权页面
3. 资源拥有者授权
4. 授权服务生成授权码
5. 通过回调地址重定向到第三方软件，并携带授权码
6. 第三方软件获取授权码，发送请求
7. 授权服务生成 access_token，并返回
8. 第三方软件通过 access_token 访问受保护资源

如果在第 4 步，没有授权码，而是直接返回 access_token。那么就不能使用重定向的方式，因为这样会把 access_token 暴露在浏览器上，从而面临访问令牌失窃的风险

在获取 access_token 之前，第三方软件和授权服务之前是通过浏览器这个中间人进行间接通信的


授权服务流程
第三方软件注册

```java
Map<String, String> appMap = new HashMap<String, String>();

appMap.put("app_id", "");
appMap.put("app_secret", "");
appMap.put("redirect_url", "");
appMap.put("scope", "nickname,address,pic");
```

颁发授权 code

准备阶段
验证基本信息：对第三方软件合法性和回调地址合法性校验
验证权限范围：若请求过来的权限范围大于注册范围，提示越权
生成授权页面：资源拥有者可以在授权页面选择缩小权限范围

生成授权码
验证权限范围：用资源拥有者授权之后的权限和第三方软件注册的权限做校验
生成授权码：将生成的授权码与 app_id、user 进行关联映射，以便在生成 access_token 时使用。安全起见，给授权码设置一个有效期。同时，将生成的授权码跟已经授权的权限范围绑定存储
重定向到第三方软件：通过重定向方式将授权码告知第三方软件

颁发 access_token

验证第三方软件
验证授权码：授权码一旦被使用，须立即作废
生成 access_token：将授权范围与 access_token 绑定，并为 access_token 设置一个过期时间。包含信息的令牌称之为结构化令牌，简称 JWT

access_token 是有过期时间的，为了避免资源拥有者重复授权，引入刷新令牌

颁发刷新令牌：第三方软件得到一个访问令牌的同时，也会得到一个刷新令牌
使用刷新令牌：一个刷新令牌被使用之后，授权服务需要将其废弃，并重新生成一个刷新令牌


jwt 构成
header: 令牌类型和算法等信息。typ 为 JWT 表示 PAYLOAD 是 JWT 类型，alg 表示签名算法
payload: JWT 数据体，代表一组数据。其中，sub 为令牌主体，一般设为资源拥有者的唯一标识；exp 为令牌的过期时间戳；lat 为令牌颁发的时间戳
signature: JWT 信息的签名

授权服务颁发 jwt 令牌给第三方软件，第三方软件使用 jwt 令牌请求受保护资源服务。jwt 令牌需要在公网上做传输，在传输过程中，jwt 令牌需要进行 Base64 编码以防止乱码，同时还需要进行签名及加密处理来防止数据信息泄露

jwt 优势
1. 计算代替存储
2. jwt 内部包含重要信息，在整个传输过程中都必须要求密文传输
3. jwt 格式的令牌通过自编码的方式包含了身份验证需要的信息，不再需要服务端的额外存储，每次请求都是无状态的。增强了系统的可用性和伸缩性

jwt 问题：难以在使用过程中修改令牌状态。例如，在使用第三方软件的时候，如果突然修改了密码，就需要将令牌设置为无效。但是，使用 jwt 令牌时，每次颁发的令牌都不在服务端存储，这样就无法改变令牌状态了。这意味着，jwt 令牌在有效期内，可以横行无止。

为了解决这个问题，通常有两种做法：

1. 每次生成 jwt 令牌时的密钥粒度缩小到用户级别，当用户取消授权或者修改密码后，让这个密钥一起修改
2. 在没有用户主动取消授权的环境里面，只考虑修改密码的情况下，可以把用户密码作为 jwt 密钥。这样，用户修改密码就相当于修改了密钥

令牌生命周期
jwt 令牌可以把有效期的信息存储在本身的结构体中


第三方软件工作

1. 注册信息
2. 引导授权
3. 使用访问令牌

使用访问令牌请求的方式有三种：
1. 表单参数
2. URL 查询参数
3. 授权请求头部字段

4. 使用刷新令牌

保留 expires_in 值保存下来并定时检测

受保护资源权限范围
1. 不同权限对应不同的操作
2. 不同权限对应不同的数据
3. 不同用户对应不同的数据


授权码这种临时的中间值，让资源拥有者参与进来，从而让第三方软件与授权服务之间建立联系，进而让第三方软件代表资源拥有者去访问受保护资源

但是，如果第三方软件是授权服务自家出品的，是被充分信任的，就没有必要再使用授权码许可类型进行授权了。在这种场景下，可以使用资源拥有者凭据许可类型

资源拥有者凭据就是用户的凭据，就是用户名和密码

资源拥有者凭据许可类型的流程
1. 用户访问第三方软件，提示输入用户名和密码
2. 第三方软件向授权服务请求 access_token，附带用户名和密码，此时 grant_type 为 password
3. 授权服务验证用户名和密码之后，生成 access_token 的值并返回给第三方软件
4. 第三方软件使用 access_token 访问受保护的资源

客户端凭据许可
如果没有明确的资源拥有者，第三方软件访问了一个不需要用户授权的数据。在这种场景下授权，就是客户端凭据许可。第三方软件直接通过注册时的 app_id 和 app_secret 换回 access_token。此时，第三方软件可以随时发起请求获取 access_token，因此这种授权不需要刷新令牌

客户端凭据许可流程：
1. 第三方软件向授权服务请求 access_token，附带 app_id 和 app_secret。此时 grant_type 为 client_credentials
2. 授权服务返回 access_token
3. 第三方软件使用 access_token 访问受保护的资源

隐式许可
如果第三方软件没有后端服务，就是在浏览器中执行的，这种情况下的授权流程就可以使用隐式许可流程

隐式许可流程：
1. 用户通过浏览器访问第三方软件，此时，第三方软件相当于是嵌入到浏览器中的应用程序
2. 第三方软件向授权服务请求 access_token
3. 授权服务生成 access_token 返回给第三方软件
4. 第三方软件使用 access_token 访问受保护的资源


没有 server 端的 app
1. app 生成一个随机的、长度 43 - 128 字符之间的、参数为 code_verifier 的字符串验证码
2. 利用 code_verifier 生成挑战码参数 code_challenge。如果 code_challenge_method 参数值为 plain，则生成的 code_challenge 值就是 code_verifier 的值；如果 code_challenge_method 参数的值为 S256，则将 code_verifier 进行 ascii 编码之后再进行哈希，然后将哈希之后的值进行 base64 编码
3. 向授权服务请求授权码，附带参数 code_challenge，code_challenge_method
4. 授权服务保存 code_challenge，code_challenge_method，返回授权码
5. app 向授权服务请求 access_token，附带参数 code, code_verifier
6. 授权服务重新生成 code_challenge 进行校验，之后返回 access_token

有 server 端的 app
1. 微信用户请求登录第三方 app
2. app 请求微信授权，拉起微信 app
3. 微信开放平台等待微信用户确认
4. 用户确认，微信开放平台返回授权码
5. app 使用授权码向微信开放平台请求 access_token
6. 微信开放平台返回 access_token

auth2 安全
csrf 攻击
恶意软件让浏览器向已完成用户身份认证的网站发起请求，并执行有害操作

攻击者先通过自己的第三方软件账号做了微信绑定操作，也就可以使用自己的微信账号来登录第三方软件来。然后，攻击者在发起了一个授权请求后构造了一个攻击页面，诱导用户 G 点击

```html
<html>
    <img src="https://xxx/callback?code=codeA">
</html>
```

而用户 G 已经使用第三方软件的账号登录了第三方软件，此时正要去做跟微信账号的绑定。如果这个时候他刚好点击了攻击者设置的这个恶意页面，那么后面换取授权的访问令牌 access_token，以及通过 access_token 获取的信息就是攻击者的了

这就相当于用户将自己的第三方软件账号跟攻击者的微信账号绑定在了一起，这样攻击者就能通过自己的微信账号来登录用户的第三方软件了

使用随机值为 state 参数
当第三方软件请求授权码的时候附带一个自己生成的 state 参数，同时授权服务也要按照规则将这个随机 state 值跟授权码 code 一起返回给第三方软件。这样，第三方软件接收到授权码的时候，就对 state 参数进行校验，不同就拒绝后续流程

本质就是：攻击者用自己的授权码 codeA 的值，通过 csrf 攻击，替换了用户 G 的授权码的值

xss 攻击
xss 攻击的主要手段是将恶意脚步注入到请求的输入中

修复 xss 漏洞的方法就是对非法信息做转义过滤

水平越权
水平越权是指在请求受保护资源服务数据的时候，服务端应用程序未校验这条数据是否归属于当前授权的请求用户

授权码失窃
解决方案
1. 授权服务在进行授权码校验的时候，也对 app_id 进行校验
2. 第三方软件在使用过一次校验码之后，授权服务删除授权码

重定向 uri 被篡改
解决方案
对重定向 uri 进行完整性校验

OIDC
OpenID Connect
EU: 最终用户
RP: 认证服务和依赖方
OP: 身份认证服务方

OIDC 通信流程
1. 访问第三方软件
2. 第三方软件重定向到认证服务，认证服务重定向到登录页面
3. 用户登录，认证服务记录登录状态，生成 code 值
4. 认证服务重定向到第三方软件，附带 code 值
5. 第三方软件发送 post 请求，附带 code 值
6. 认证服务生成 id token、access_token 并返回
7. 第三方软件记录登录状态

id 令牌是一个 jwt 格式的令牌，需要以下 5 个 jwt 声明的参数：
iss: 令牌的颁发者，其值就是身份认证服务的 URL
sub: 令牌的主题，其值是一个能够代表最终用户的全局唯一标识符
aud: 令牌的目标受众，其值是第三方软件的 app_id
exp: 令牌的到期时间戳，所有 id 令牌都会有一个过期时间
iat: 颁发令牌的时间戳

第三方软件解析并验证 id 令牌的合法性之后，保留其中的 payload 部分

单点登录
1. 访问第三方软件
2. 第三方软件重定向到认证服务，然后跳转到登录页面
3. 用户登录
4. 认证服务重定向到第三方软件，附带 code 信息
5. 第三方软件发送 post 请求，附带 code 信息
6. 认证服务生成 access_token、id 并返回给第三方软件
7. 第三方软件记录登录状态


id 令牌 id_token 是在访问令牌 access_token 基础上的补充，而不是替换访问令牌。而且，这两种令牌还具有不同的生命周期，id 令牌通常会很快过期。id 令牌代表一个单独的身份认证结果，并且永远不会传递给外部服务，而访问令牌可以在用户离开后的很长时间内用于获取受保护资源


gateway 网关层
1. 令牌的校验和转换，校验前端传过来的访问令牌，并转换为包含用户和权限信息的 jwt 令牌，再将 jwt 令牌向后台微服务传递
2. 权限校验，根据请求令牌中的权限范围 scope 判断请求是否具有调用后台服务的权限

